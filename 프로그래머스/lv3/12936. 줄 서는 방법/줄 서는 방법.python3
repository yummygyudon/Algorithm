def factorial(n) :
    if n < 1 :
        return 0
    dp = [0] * (n+1) # 6팩토리얼
    dp[1] = 1
    for i in range(2, n+1) :
        dp[i] = dp[i-1] * i #  6,4
    return dp[n]

  
def solution(n, k) :
    result=[]
    person = [i for i in range(1,n+1)]
    """
    4명(n) - 15번(k)의 경우
    [1, 2, 3, 4] -> [3, 2, 1, 4]
    
    4명(n) - 18번(k)의 경우
    [1, 2, 3, 4] -> [3, 4, 2, 1]
    """
    for i in range(n) : # 4번
        if k == 0 :
            result += person[::-1]
            break
        """
        나머지가 있을 경우 -> k번째 값의 마지막
        나머지가 없을 경우 -> k번째 값 시작 
        
        1회차 : 3! [1,2,3,4]
        : 15 // 6 = 2 (k) 
        나머지가 있다 -> k+1번째 값 무조건 사용된다  
        : 15 % 6 = 3( idx )
        -> 다음 순서에 가능한 경우의 수 -> k = 3 
        
        2회차 : 2! [1,2,4]
        : 3(k) // 2 = 1(k)
        나머지가 있다 -> k+1번째 값 무조건 사용된다      
        : 3 % 2 = 1(idx)
        -> 다음 순서에 가능한 경우의 수 -> k = 1
        
        3회차 : 1 ! [1,4]
        : 1 // 1 = 1(k)
        나머지가 없다 ->  k번째 값 사용되고 뒤에 얼마나 남아있든 순서대로
        : 1 % 1 = 0(idx)
        -> 다음 순서에 가능한 경우의 수 -> k = 1
        
        4회차 : 0!
        : 0 // 0 = 0(k)
        : 0 % 0 = 0(idx)
        
        ------------------------------
        
        1회차 : 3! [1,2,3,4]
        : 18 // 6 = 3 (k) 
        나머지가 없다 -> k번째 값이 사용된다  
        : 18 % 6 = 0( idx )
        -> 다음 순서에 가능한 경우의 수 -> k = 3 
        
        2회차 : 2! [1,2,4]
        : 3(k) // 2 = 1(k)
        나머지가 있다 -> k+1번째 값 무조건 사용된다      
        : 3 % 2 = 1(idx)
        -> 다음 순서에 가능한 경우의 수 -> k = 1
        
        3회차 : 1 ! [1,4]
        : 1 // 1 = 1(k)
        나머지가 없다 ->  k번째 값 사용되고 뒤에 얼마나 남아있든 순서대로
        : 1 % 1 = 0(idx)
        -> 다음 순서에 가능한 경우의 수 -> k = 1
        
        4회차 : 0!
        : 0 // 0 = 0(k)
        : 0 % 0 = 0(idx)
        """
        cycle = k//factorial(n-1)
        k %= factorial(n-1)
        if k > 0 :
            result.append(person[cycle])
            person.pop(cycle)
        else :
            # 다음 순서부터 k=0이기 때문에 더이상 돌 사이클 없다 == 가장 마지막 순서 == 현재 상황에서 가장 큰 순서대로 나열
            # 최초 발견시 우선적으로 마지막 사이클 마무리 -> 다음 자릿수 for문에서 역순 나열
            result.append(person[cycle-1])
            person.pop(cycle-1)
        n-=1
    return result
